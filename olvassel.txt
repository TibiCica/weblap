# Minecraft

1. Készítette: Kovács Kristóf Dániel

2. Weblap URL: https://tibicica.github.io/weblap/index.html

3. A weboldal a Minecraft világának egy apró töredékét mutatja be: a játékot, az élővilágát, a lehetőségeit, illetve a történelmét röviden és tömören.

4. Saját JavaScript kódok:
    univerzális:
        funfact: minden oldal "aside" elemébe (képernyő függvényében alul, vagy oldalt) véletlenszerűen kisorsol egyet az előre rögzített 13 érdekességből
    mobs.html:
        a) mob: a mobokat objektumként kezelem. A mob objektumban 6 tulajdonság van és egy mob deklarásakor 5 adat van bekérve: név, életerőpont, sebzés, típus, dimenzió. A 6-ik tulajdonsága a képek, ami a képekhez való útvonalból, a mob nevéből egybe írva (a szóközöket eltörölve) és a kép kiterjesztéséből áll. A "mob" functionon belül is lehetséges lett volna megoldani, hogy a kép meglegyen, azonban én a "foreach"-et használtam kívülről gyakorlásképp.
        b) mobok kiválasztása
            I. addplayer: a "mobs" div elementhez mindenféleképp hozzá van rendelve a játékos karaktere és a statisztikák. Ez az abábbiféleképpen jelenik meg: egy div elemet létrehozok, amit a "mob" osztállyal ruházok fel, majd hozzáadom a következő elemeket: img, aminek az alapértelmezett (Steve) skint állítom be, az id-je "creature" és az alternatív szöveg meg a mob neve; egy h1, ami a mob nevét jelzi ki; egy további div-et, amiben szöveg és képek vannak: "HP:" és utána for ciklussal félszívekkel feltöltöm az életerőpontokkal a következő sort - minden második félszív megfordítva egy egész szív látszatát keltve -, majd "Atk:" és ugyanúgy félszívekkel a sebzést jelezve.
            II. loadmob: ugyanaz, mint az addplayer azzal a különbséggel, hogy itt van egy bekért adat: a mob. A mob és fix adatok helyett az egyedből kinyeri az adatokat, köztük a képet, a nevet, az életerőt és a támadást.
            III. changepicture: ez a függvény a "mobs" tartalmának a törlésével, majd az addplayer meghívásával kezdődik, amit két egymásba ágyazott foreach követ: az első a mob objektumokon fut át, míg a másik a "mobbinos" id-jű multiopcionális select lista elemein megy keresztül és azon belül van a két foreach aktuális eleme összehasonlítva, ami ha igaz, akkor a loadmob meg lesz hívva, aminek a bemenete az aktuális mob, egyébként tovább fut.
            IV. sel2: a 3-ik elvén működik azzal a különbséggel, hogy itt azt vizsgálja, hogy a dimenziók vannak vizsgálva. Mivel egy mob több dimenzióban is létezhet, ezért nem teljes, hanem részleges egyezést keresünk és amiért több dimenziót is vizsgálunk, a redundancia elkerülése érdekében a foreach-be itt every van ágyazva, mivel a foreach nem break-elhető és az every-ből akkor léphetünk ki, ha a visszatérési érték nem pozitív, így true esetén tovább fut, false esetén meg meghívon a loadmob függvényt. A b)III. megoldás is lehetséges every-vel és gyorsabb is lenne a lefutása, mert így az első jó elemnél leáll a ciklus.
            V. sel3: Az előző kettőhöz hasonlóan kezdődik, itt viszont nem multiopciós lista van, hanem kereső és nem a kiválasztott elemek változtatására aktiválódik, hanem a billentyűgomb felengedésére, amire azért van szükség, hogy biztosak legyünk benne, hogy az input szöveg teljes, mikor a függvény lefut. Az a)IV.-hez hasonlóan azt vizsgáljuk, hogy a szöveget tartalmazza-e a mob neve és a foreach azért hasznosabb itt, mint az every, mert itt fontos, hogy minden lehetőségen átmenjünk, amit a felhasználó keresne. Nem case sensitive, úgyhogy kis- és nagybetűket oda lehet tenni, ahova szeretnénk, mert a függvény a mob nevét és a bevitt szöveget átváltja kisbetűs karakterre, mikor összehasonlítja a kettőt.
        c) mobsel: radio alapján aktiválódnak és deaktiválódnak az egyes bemeneti elemek, amikkel interaktálhat a felhasznaló
    about.html:
        cave: A függvény egy "lgt", azaz hossz értéket kér el. Ez alapján alkotunk egy mátrixot, aminek a mérete lgt * lgt/2, azaz a magasság a hossz fele. A mátrix eleinte egyesekkel van feltöltve, de utána a széleit leszámítva az egészet nullásokkal töltjük fel. Ezt követően az alsó és a felső sorokat párhuzamosan töltjük fel egyesekkel a következő szabály alapján: ha vagy az elem alatt, vagy felett 1 van, akkor 50% eséllyel ez is egyes lesz. Amennyiben ez nem lett egyes, de van az egyik oldalán egy 1 értékű cella, akkor megint 50%-os eséllyel lehet egyes (azaz ami alatt és mellett is van 1, az 75%-os eséllyel 1 lesz). Amennyiben egyik alkalommal sem jött össze, az értéke 0 lesz. Miután a feltöltés készen van, az elemeket megvizsgáljuk: különböző értékeket kapnak azon 0 értékű cellák, melyek jobboldalán, alatt, mindkettő oldalán vannak 1-esek (2, 3, 4), illetve az is kapott, aminek a sarkában volt (5), de ez már jelentőségét vesztette, így ez nem csinál semmit. A különböző számok nem jelennek meg, csak ezek alapján készűlt táblázat és a különböző számok a cellák osztályait határozták meg: 0 semmi, 1 a kő, ami a háttér színét adja a cellának, a 3 a "surface", ami alulra ad egy oldalvonalat, a 4 a "side", ami oldalra ad vonalat, a 2 az "surface side", ami mindkezző, az 5 meg "corner", ami jelentőségét vesztette, így a 0-hoz hasonlóan semmi. 
5. Betűtípus:
    a) Alapértelmezett: Arial, Helvetica, sans-serif
    b) Alcímek, címek, nevek, nav lista: Minecraft
6. A weboldalon a külső forrásból eredeztethető kódok mindegyike enyhén szólva Theseus hajója: ha látszik is, hogy mi az alapja, bőven kivehető, hogy már nem az eredeti.